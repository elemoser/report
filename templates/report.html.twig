{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Report</h1>

    <p>
        På denna sidan samlar jag mina redovisningstexter för kursens kmom.
    </p>

    <ul class="nav-report">
        <li><a class="button lila-button" href="#kmom01">Kmom01</a></li>
        <li><a class="button lila-button" href="#kmom02">Kmom02</a></li>
        <li><a class="button lila-button" href="#kmom03">Kmom03</a></li>
        <li><a class="button lila-button" href="#kmom04">Kmom04</a></li>
        <li><a class="button" href="#kmom05">Kmom05</a></li>
        <li><a class="button" href="#kmom06">Kmom06</a></li>
        <li><a class="button" href="#kmom10">Kmom07/10</a></li>
    </ul>

    <section>
    <h2 id="kmom01">Kmom01</h2>
    <p>
        Jag har inte mycket erfarenhet av objektorienterad programmering.
        Förra kvartalet gick jag kursen Algoritmer och datastrukturer med objektorienterad Python, där jag lärde mig grunderna i objektorienterad programmering med Python.
        Jag tyckte att det var utmanande men mycket spännande och lärorik.
    </p>
    <p>
        Hittills kan jag se många likheter mellan Python och PHP.
        Precis som i Python definieras klasser i PHP med nyckelordet <i>class</i>.
        Klasser kan innehålla en konstruktionsmetod (<code>__constructor()</code>) men behöver inte göra det.
        Variabler inom en klass kallas <i>properties</i> och funktioner kallas <i>metoder</i>.
        Precis som i Python kan properties vara av olika typer.
        Vanligast är att properties är privata, vilket innebär att de endast kan användas inom klassen.
        Om en property ska vara tillgänglig utanför klassens scope måste den definieras som en public klass.
    </p>
    <p>
        På grund av likheterna var det relativt lätt att komma igång med klasser i PHP.
        Jag stötte dock på många problem med ramverket symfony.
        Det tog mig lång tid att få mina router att fungera korrekt.
        Det tog ännu längre tid att skapa stilen med SASS, främst för att jag kör <code>npm run build</code> varje gång jag uppdaterar filerna.
        Jag är säker på att det finns ett snabbare sätt, men jag har inte hittat någon bättre lösning ännu.
        Det är därför att min crazy sida inte är så crazy ännu.
        Även om jag är fortfarande förvirrad över vissa delar av kodstrukturen, tycker jag att jag har skapat en fin sida.
        Jag hoppas att kodstrukturen och ramverket kommer att bli tydligare framöver.
    </p>
    <p>
        Det finns mycket att lära mig in denna kurs.
        Jag ser fram emot att finslipa mina färdigheter och lära mig om objektorienterad programmering med PHP. 
        Jag är särskilt intresserad av att lära mig mer om testning, som är mycket viktig för utveckling av applikationer. 
        Med testning ses till att en applikation inte går sönder när ändringar görs eller när nya funktioner läggs till
        (<a href="https://phptherightway.com/#testing">PHP The Right Way</a>).
    </p>
    <p>
        Min TIL för detta kmom handlar om <i>namespaces</i>.
        Eftersom det kan förekomma att samma klassnamn används i två eller fler olika PHP bibliotek, kan det orsaka problem när båda används i samma namnområde. 
        För att lösa detta problem har man infört namespaces.
        Med namespaces kan två PHP-klasser med samma namn existera i separata PHP namespaces.
    </p>
    </section>

    <section>
    <h2 id="kmom02">Kmom02</h2>
    <p>
    Detta kursmoment lärde vi oss om de objektorienterade konstruktionerna arv, komposition, interface och trait.
    </p>

    <p>
    <b>Arv</b> är en relation mellan två klasser, där den ena klassen ärver egenskaper och metoder från den andra klassen.
    Detta innebär att den ärvande klassen tar över all funktionalitet från den förälder-klassen, plus att den kan lägga till sin egen funktionalitet.
    I PHP implementeras arv med hjälp av nyckelordet "extends".
    </p>

    <p>
    <b>Komposition</b> är en annan typ av relation mellan klasser.
    Man pratar om komposition när en klass innehåller eller anropar en annan klass som en del av sin struktur.
    Istället för att ärva från en klass, skapar man en instans av den andra klassen inuti den första klassen.
    Detta kallas för hög koppling (high coupling).
    Det är också möjligt att skicka in en klass i en metod av en annan klass.
    Detta kallas för lös koppling (loose coupling).
    Med komposition kan man skapa mer flexibla och modulära klasser.
    </p>

    <p>
    Ett <b>interface</b> är en samling av metoder som en klass måste implementera.
    Detta kan användas för att tvinga klasser att följa en viss struktur eller för att skapa abstrakta typer som andra klasser kan implementera.
    I PHP definieras ett interface med nyckelordet "interface".
    </p>

    <p>
    Ett <b>trait</b> är en samling av metoder som kan återanvändas av flera klasser.
    Detta är användbart om man har en del kod som behöver återanvändas på flera ställen,
    men som inte är lämpligt att lägga i en bas-klass eller ett interface.
    I PHP definieras en trait med nyckelordet "trait" och inkluderas i en klass med hjälp av nyckelordet "use".
    </p>

    <p>
    För detta kursmomentets uppgift skapade jag fyra klasser: <code>Card</code>, <code>CardGraphic</code>, <code>CardCollection</code> och <code>DeckOfCards</code>.
    <b>Card</b> klassen representerar ett spelkort. Den har egenskaper för kortets färg,
    lägsta och högsta värde och en konstruktör som slumpmässigt tilldelar kortet en färg och ett värde om inget anges.
    Den har också metoder för att rita ett nytt kort, hämta kortets värde, hämta en strängrepresentation av kortet och hämta kortets färg.
    </p>

    <p>
    <b>CardGraphic</b> ärver från Card-klassen och har ytterligare en privat egenskap $representation som är en array som mappar varje möjligt kortvärde till en motsvarande Unicode-teckenrepresentation av kortets färg och nummer.
    Istället för att returnera en sträng, returnerar metoden <code>getAsString()</code> i denna klassan en Unicode-teckenrepresentationen av kortets färg och nummer.
    </p>

    <p>
    Klassen <b>CardCollection</b> representerar en samling spelkort, med metoder för att lägga till och ta bort kort, blanda samlingen, få fram antalet kort, få fram värden, färger och strängar för korten och slumpmässigt dra ett visst antal kort från samlingen.
    Klassen använder ett Card-objekt som parameter för vissa metoder.
    </p>

    <p>
    Klassen <b>DeckOfCards</b> ärver från klassen CardCollection och representerar en komplett kortlek. Den har en metod <code>isCompleteDeck()</code> som kontrollerar om kortleken har alla 52 kort. Metoden beräknar det förväntade antalet kort baserat på kortets min- och maxvärden och jämför det med det faktiska antalet kort i kortleken.
    </p>

    <p>
    Jag upplevde det som mycket användbart att skapa ett UML-diagram över klasserna innan jag började koda.
    Genom att visualisera klasserna på detta sätt fick jag en bättre förståelse för deras hierarkiska struktur och relationer till varandra.
    Jag uppdaterade diagrammet även under arbetet med koden, när jag såg inkonsekvenser eller behov av förbättringar. 
    </p>

    <p>
    För att ta itu med några av de svårare delarna av uppgifter har jag funnit det användbart att använda pseudokod.
    Jag har dock lagt märke till att jag tenderar att radera min pseudokod “as I go along”, så det finns ofta väldigt lite kvar när jag har skrivit färdigt koden.
    Därför kan det hända att man bara hittar några få spridda rader pseudokod i mina filer.
    </p>

    <p>
    Jag tycker att jag på det hela taget gjorde ett bra jobb.
    Jag lyckades till exempel hitta ett sätt att skapa en lös koppling mellan Card/CardGraphic-klassen och CardCollection/DeckOfCards-klassen, vilket var en större utmaning än väntat.
    Det finns dock fortfarande utrymme för förbättringar.
    Till exempel är DeckOfCards-klassen för närvarande onödig.
    Jag skulle kunna använda CardCollection-klassen i stället, eftersom i slutändan använde jag inte metoden <code>isCompleteDeck()</code> i DeckOfCards.
    Särskiljning kan dock komma till nytta i framtiden.
    </p>

    <p>
    Min TIL handlar om “loose coupling high cohesion” eller på svenska “lös koppling hög kohesion”.
    Lös koppling och hög kohesion är två principer för programvarudesign som bidrar till att skapa robust och underhållbar kod.
    Med <i>lös koppling</i> avses i vilken grad komponenterna i ett system är oberoende och inte beroende av varandra för att fungera.
    I ett löst kopplat system har ändringar som görs i en komponent minimal inverkan på andra komponenter.
    Detta gör det lättare att ändra, testa och underhålla systemet som helhet.
    Lös koppling uppnås genom att man använder väldefinierade gränssnitt och minimerar beroenden mellan komponenterna (såsom klasser).
    Med <i>hög kohesion</i> avses i vilken grad elementen inom en komponent är relaterade till varandra och arbetar tillsammans för att uppnå en enda, väldefinierad uppgift eller ett väldefinierat syfte. En komponent med hög sammanhållning är inriktad på ett specifikt och väldefinierat ansvar och har ett klart och tydligt gränssnitt mot andra komponenter. Detta gör det lättare att resonera om, testa och underhålla komponenten.
    Tillsammans kan lös koppling och hög sammanhållning leda till system som är modulära,
    flexibla och motståndskraftiga mot förändringar.
    </p>
    </section>

    <h2 id="kmom03">Kmom03</h2>
    <section>
    <p>
        Detta kursmoment utvecklade jag ett kortspel som heter Tjugoett från grunden.
        För att säkerställa en välstrukturerad kod och en smidig spelupplevelse började jag med att skapa ett flödesschema, pseudokod och ett UML-klassdiagram. 
        Dessa verktyg hjälpte mig att konceptualisera och modellera spelmekaniken samt planera kodstrukturen i förväg.
        Jag upptäckte att användningen av dem var avgörande för problemlösning och för att säkerställa en god implementering av spelet.
    </p>
    <p>
        UML-diagrammet var ett viktigt verktyg för att planera de klasser som krävdes för mitt projekt.
        Förutom de tre klasser som jag skapade för den sista kmoms-uppgiften lade jag till ytterligare tre klasser som alla beskrivs på spelets dokumentationssida.
        Flödesschemat och pseudokoden var också till hjälp för att förstå spelets flöde och villkoren för att vinna/förlora, som du också hittar på <a class="link" href="{{ path('game_doc') }}">dokumentationssidan</a>.
    </p>
    <p>
        Jag är nöjd med hur jag strukturerade min kod och hur mitt spel blev.
        Det finns dock några element som planerats i UML-diagrammet
        och flödesschemat som jag har tagit bort eller planerar att ta bort eftersom de är onödiga i det här läget.
        Till exempel fördefinierar klassen <code>Bank</code> endast spelarens namn till "bank" utan att definiera några andra klasspecifika egenskaper eller metoder,
        och jag tror att det kanske inte behövs. Samma gäller för metoderna <code>removeCard</code> och <code>removePlayer</code> som definieras i UML-diagrammet.
        Jag implementerade dem aldrig, eftersom det visade sig att de var nödvändiga.
    </p>
    <p>
        Andra delar av koden kan förbättras.
        Till exempel klarar inte metoden <code>checkWinStatus</code> i klassen <code>Game21</code> phpmd-testet på grund av att den innehåller för många if-satser och for-loopar.
        Även om jag har ägnat en del tid åt att refaktorera koden för att göra den mindre komplex har jag inte hittat någon lösning som fungerar ännu.
        Tills vidare måste jag ignorera dessa varningsmeddelanden.
    </p>
    <p>
        När det kommer till mitt arbete med Symfony kan jag säga att jag initialt stötte på många problem med rendering, vilket gjorde mig frustrerad och överväldigad.
        Men efter att ha arbetat med Symfony i tre kursmoment har jag nu utvecklat en större bekvämlighet och säkerhet i min förståelse för hur ramverket fungerar.
    </p>
    <p>
        Min TIL handlar om cyklomatisk komplexitet (d.v.s. <i>cyclomatic complexity</i>),
        vilket är ett mått som används för att mäta komplexiteten hos ett program.
        Den beräknas utifrån antalet oberoende vägar i ett programs källkod.
        En högre cyklomatisk komplexitet indikerar att ett program är mer komplext och kan vara svårare att testa, underhålla och förstå.
    </p>
    </section>
    <h2 id="kmom04">Kmom04</h2>
    <section>
    <p>
        Under detta kursmoment lärde vi oss om enhetstestning med <i>phpunit</i>.
        Eftersom jag hade tidigare erfarenhet av enhetstestning från kursen <i>Objektorienterad programmering med Python</i> var det ganska lätt att tillämpa begreppen på min kod med hjälp av phpunit.
        Jag stötte dock på några utmaningar när jag satte upp miljön för enhetstestning med php.
        Det tog mig nästan en dag vardera att installera Xdebug och phpunit, och det var ganska frustrerande.
        När jag slutligen lyckades installera miljön kunde jag slutföra veckans uppgift utan problem.
        Jag kunde uppnå en kodtäckning på 100 % för mina klasser Card och Game21 i php-code-coverage verktyget.
    </p>
    <p>
        Generellt sett var min kod lätt att testa, och jag är nöjd med strukturen och skrivandet av min kod.
        Klassen Game21 utgjorde dock en utmaning när det gällde enhetstestning.
        Eftersom dess metoder är starkt beroende av andra klasser var testmetoderna för den här klassen mer komplexa än för de andra klasserna.
        Testning av vissa metoder i Game21-klassen, som <code>getHandTotal()</code> och <code>checkWinStatus()</code>, visade sig vara särskilt utmanande på grund av behovet av att täcka in flera testfall.
    </p>
    <p>
        Trots dessa utmaningar gjorde testprocessen det möjligt för mig att identifiera och korrigera flera brister och fel i min kod.
        Jag har övervägt att ta bort eller skriva om vissa klasser och metoder för att förbättra testbarheten,
        men jag tvekar att göra det eftersom min nuvarande kod fungerar och går bra att testa.
        Jag vill inte riskera att bryta sönder något genom att göra stora ändringar.
    </p>
    <p>
        Jag håller med att testbar kod kan vara ett tecken på "fin och ren kod", men de två begreppen är inte utbytbara.
        Testbar kod är kod som har skrivits på ett sätt som gör det lätt att skriva tester för den.
        Detta innebär att koden vanligtvis är modulär, löst kopplad och har väldefinierade gränssnitt.
        Testbar kod är också vanligtvis välstrukturerad, med tydlig separering av problemområden och fokus på underhållbarhet.
    </p>
    <p>
        Å andra sidan är "fin och ren kod" en mer subjektiv term som omfattar en bredare uppsättning principer.
        Fin eller ren kod är kod som är lätt att läsa, lätt att förstå och lätt att ändra.
        Det är kod som följer etablerade kodningsstandarder och bästa praxis, t.ex. namnkonventioner, kodformatering och kommentering.
        Verktyg som php-cs-fixer, phpstan och phpmd hjälper oss att skriva “fin och ren” kod.
    </p>
    <p>
        Testbar kod är ofta ren kod, men ren kod är inte nödvändigtvis testbar kod.
        Det är möjligt att skriva ren kod som är svår att testa, t.ex. om koden är tätt kopplad eller saknar tydlig separation av problem.
        Som diskuterats ovan stötte jag själv på det här problemet när jag skrev enhetstesterna för klasserna Player och Game21.
    </p>
    <p>
        Min TIL för detta kmom handlar om PHPDoc, som är för PHP vad JSDoc är för JavaScript (som vi introducerades till i JavaScript kursen).
        PHPDoc är alltså en dokumentationsstandard för PHP-kod.
        Genom att använda PHPDoc-standard kan utvecklare enkelt generera API-dokumentation från koden
        och hjälpa till att underlätta förståelsen av koden för andra utvecklare.
        PHPDoc-formatet följer en specifik syntax som definierar vilken information som ska inkluderas i kommentarerna.
        Vanligtvis inkluderar det information om funktioner och metoder, dessa indata och utdata, variabler och parametrar, samt deras datatyper och beskrivningar.
    </p>
    </section>
    <h2 id="kmom05">Kmom05</h2>
    <h2 id="kmom06">Kmom06</h2>
    <h2 id="kmom10">Kmom07/10</h2>
{% endblock %}